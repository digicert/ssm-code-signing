"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.installToolsBasedOnOS = exports.getOS = void 0;
const os_1 = __importDefault(require("os"));
const installwindowsTools_1 = require("./installwindowsTools");
const installLinuxTools_1 = require("./installLinuxTools");
exports.getOS = () => os_1.default.type();
const OSToToolMapper = {
    linux: "smtools-linux-x64.zip",
    win32: "smtools-windows-x64.msi",
};
function installToolsBasedOnOS(installationPath) {
    return __awaiter(this, void 0, void 0, function* () {
        let OS = exports.getOS();
        switch (OS) {
            case "Darwin":
                console.log("MacOS");
                break;
            case "Linux":
                OS = "linux";
                break;
            case "Windows_NT":
                OS = "win32";
                break;
        }
        console.log("os type", OS);
        if (!OSToToolMapper.hasOwnProperty(OS)) {
            throw new Error("Mac OS is not yet supported");
        }
        const toolToBeUsed = OSToToolMapper[OS];
        if (OS == "win32") {
            return installwindowsTools_1.installWindowsTools(installationPath, toolToBeUsed);
            // pkcs11FileName = "smpkcs11.dll";
        }
        else if (OS == "linux") {
            installLinuxTools_1.installLinuxTools(installationPath, toolToBeUsed);
            // let setExecutableFlagForSmctl: tr.ToolRunner = tl
            //   .tool("chmod")
            //   .arg("+x")
            //   .arg(path.join(extractPath, "smctl"));
            // let syncRetCode: number = await setExecutableFlagForSmctl.exec();
            // console.log("set executable flag for smctl" + syncRetCode);
            // pkcs11FileName = "smpkcs11.so";
        }
        // const configFilePath = path.join(extractPath, "pkcs11properties.cfg");
        // console.info(
        //   "The pkcs11 library path set is ",
        //   path.join(extractPath, pkcs11FileName), "and config file path is ", configFilePath
        // );
        // fs.writeFileSync(
        //   configFilePath,
        //   `name=signingmanager\r\nlibrary=${path.join(
        //     extractPath,
        //     pkcs11FileName
        //   )}\r\nslotListIndex=0`
        // );
        // return configFilePath;
    });
}
exports.installToolsBasedOnOS = installToolsBasedOnOS;
// async function runToolBasedInstallationOrExtraction(
//   toolToBeUsed: string,
//   tempDirectoryPath: string
// ) {
//   const urlToDownloadTool = `${uiAPIPrefix}/releases/noauth/${toolToBeUsed}/download`;
//   console.log(
//     "Tool to be downloaded and used {} and url is {}",
//     toolToBeUsed,
//     urlToDownloadTool
//   );
//   const toolFileData = await getAPICall(urlToDownloadTool, {
//     responseType: "arraybuffer",
//   });
//   //file writing part
//   const clientToolsDownloadPath = path.join(tempDirectoryPath, toolToBeUsed);
//   fs.writeFileSync(clientToolsDownloadPath, toolFileData);
//   console.log("file after write ", fs.statSync(clientToolsDownloadPath).size);
//   let extractPath = "";
//   if (toolToBeUsed.includes(".zip")) {
//     console.log(
//       "tool is in a zip file trying to extract it",
//       clientToolsDownloadPath
//     );
//     await extract(
//       clientToolsDownloadPath as string,
//       {dir: tempDirectoryPath}
//     );
//     extractPath = path.join(
//       tempDirectoryPath,
//       toolToBeUsed.replace(".zip", "")
//     );
//     console.log("zip extraction complete , path is ", extractPath);
//   } else if (toolToBeUsed.includes(".msi")) {
//     extractPath = path.join(
//       tempDirectoryPath,
//       toolToBeUsed.replace(".msi", "")
//     );
//     let msiRunner: tr.ToolRunner = tl
//       .tool("msiexec")
//       .arg([
//         `/i`,
//         `${tempDirectoryPath}\\${toolToBeUsed}`,
//         "/quiet",
//         `INSTALLDIR=${extractPath}`,
//       ]);
//     let regReturnCode: number = await msiRunner.exec();
//     if (regReturnCode != 0) {
//       throw new Error(
//         `Installation of msi failed with return code ${regReturnCode}`
//       );
//     }
//     console.log("installation of smctl returned code", regReturnCode);
//     //this is for self hosted agent where the installation is already completed
//     if (getAgentType() == AgentType.SELF_HOSTED) {
//       const installationLocation = tl
//         .tool("wmic")
//         .arg([
//           "product",
//           "where",
//           "Vendor='DigiCert Inc.' and name='DigiCert One Signing Manager Tools'",
//           "get",
//           "installlocation",
//           "/format:list",
//         ])
//         .execSync();
//       //clumsy but does the job
//       const { stdout } = installationLocation;
//       if (
//         stdout !== null &&
//         stdout.trim() !== "" &&
//         !stdout.includes("No Instance(s) Available")
//       ) {
//         extractPath = stdout.split("=")[1].trim();
//       } else {
//         throw new Error("Installation path is not found, internal error");
//       }
//     }
//   }
//   return extractPath;
// }
// enum AgentType {
//   AZURE_HOSTED,
//   SELF_HOSTED,
// }
// const getAgentType = () => {
//   return AgentType.SELF_HOSTED
// };
