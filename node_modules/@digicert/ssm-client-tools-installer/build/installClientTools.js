"use strict";
var __awaiter =
  (this && this.__awaiter) ||
  function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P
        ? value
        : new P(function (resolve) {
            resolve(value);
          });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done
          ? resolve(result.value)
          : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.installToolsBasedOnOS = exports.getOS = void 0;
const os_1 = __importDefault(require("os"));
const installwindowsTools_1 = require("./installwindowsTools");
const installLinuxTools_1 = require("./installLinuxTools");
exports.getOS = () => os_1.default.type();
const OSToToolMapper = {
  linux: "smtools-linux-x64.zip",
  win32: "smtools-windows-x64.msi",
};
function installToolsBasedOnOS(installationPath) {
  return __awaiter(this, void 0, void 0, function* () {
    let OS = exports.getOS();
    switch (OS) {
      case "Darwin":
        console.log("MacOS");
        break;
      case "Linux":
        OS = "linux";
        break;
      case "Windows_NT":
        OS = "win32";
        break;
    }
    console.log("os type", OS);
    if (!OSToToolMapper.hasOwnProperty(OS)) {
      throw new Error("Mac OS is not yet supported");
    }
    const toolToBeUsed = OSToToolMapper[OS];
    if (OS == "win32") {
      return installwindowsTools_1.installWindowsTools(
        installationPath,
        toolToBeUsed
      );
      // pkcs11FileName = "smpkcs11.dll";
    } else if (OS == "linux") {
      installLinuxTools_1.installLinuxTools(installationPath, toolToBeUsed);
      // let setExecutableFlagForSmctl: tr.ToolRunner = tl
      //   .tool("chmod")
      //   .arg("+x")
      //   .arg(path.join(extractPath, "smctl"));
      // let syncRetCode: number = await setExecutableFlagForSmctl.exec();
      // console.log("set executable flag for smctl" + syncRetCode);
      // pkcs11FileName = "smpkcs11.so";
    }
    // const configFilePath = path.join(extractPath, "pkcs11properties.cfg");
    // console.info(
    //   "The pkcs11 library path set is ",
    //   path.join(extractPath, pkcs11FileName), "and config file path is ", configFilePath
    // );
    // fs.writeFileSync(
    //   configFilePath,
    //   `name=signingmanager\r\nlibrary=${path.join(
    //     extractPath,
    //     pkcs11FileName
    //   )}\r\nslotListIndex=0`
    // );
    // return configFilePath;
  });
}
exports.installToolsBasedOnOS = installToolsBasedOnOS;
// async function runToolBasedInstallationOrExtraction(
//   toolToBeUsed: string,
//   tempDirectoryPath: string
// ) {
//   const urlToDownloadTool = `${uiAPIPrefix}/releases/noauth/${toolToBeUsed}/download`;
//   console.log(
//     "Tool to be downloaded and used {} and url is {}",
//     toolToBeUsed,
//     urlToDownloadTool
//   );
//   const toolFileData = await getAPICall(urlToDownloadTool, {
//     responseType: "arraybuffer",
//   });
//   //file writing part
//   const clientToolsDownloadPath = path.join(tempDirectoryPath, toolToBeUsed);
//   fs.writeFileSync(clientToolsDownloadPath, toolFileData);
//   console.log("file after write ", fs.statSync(clientToolsDownloadPath).size);
//   let extractPath = "";
//   if (toolToBeUsed.includes(".zip")) {
//     console.log(
//       "tool is in a zip file trying to extract it",
//       clientToolsDownloadPath
//     );
//     await extract(
//       clientToolsDownloadPath as string,
//       {dir: tempDirectoryPath}
//     );
//     extractPath = path.join(
//       tempDirectoryPath,
//       toolToBeUsed.replace(".zip", "")
//     );
//     console.log("zip extraction complete , path is ", extractPath);
//   } else if (toolToBeUsed.includes(".msi")) {
//     extractPath = path.join(
//       tempDirectoryPath,
//       toolToBeUsed.replace(".msi", "")
//     );
//     let msiRunner: tr.ToolRunner = tl
//       .tool("msiexec")
//       .arg([
//         `/i`,
//         `${tempDirectoryPath}\\${toolToBeUsed}`,
//         "/quiet",
//         `INSTALLDIR=${extractPath}`,
//       ]);
//     let regReturnCode: number = await msiRunner.exec();
//     if (regReturnCode != 0) {
//       throw new Error(
//         `Installation of msi failed with return code ${regReturnCode}`
//       );
//     }
//     console.log("installation of smctl returned code", regReturnCode);
//     //this is for self hosted agent where the installation is already completed
//     if (getAgentType() == AgentType.SELF_HOSTED) {
//       const installationLocation = tl
//         .tool("wmic")
//         .arg([
//           "product",
//           "where",
//           "Vendor='DigiCert Inc.' and name='DigiCert One Signing Manager Tools'",
//           "get",
//           "installlocation",
//           "/format:list",
//         ])
//         .execSync();
//       //clumsy but does the job
//       const { stdout } = installationLocation;
//       if (
//         stdout !== null &&
//         stdout.trim() !== "" &&
//         !stdout.includes("No Instance(s) Available")
//       ) {
//         extractPath = stdout.split("=")[1].trim();
//       } else {
//         throw new Error("Installation path is not found, internal error");
//       }
//     }
//   }
//   return extractPath;
// }
// enum AgentType {
//   AZURE_HOSTED,
//   SELF_HOSTED,
// }
// const getAgentType = () => {
//   return AgentType.SELF_HOSTED
// };
