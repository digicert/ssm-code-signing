import * as toolLib from "azure-pipelines-tool-lib/tool";
import fs from "fs";
import path from "path";
import * as tl from "azure-pipelines-task-lib/task";
import * as tr from "azure-pipelines-task-lib/toolrunner";
import { getAPICall, getConfigFilePath, uiAPIPrefix } from "./utils/services";
import extract from "extract-zip";
export async function runMacToolBasedInstallationOrExtraction(
  toolToBeUsed: string,
  tempDirectoryPath: string
) {
  const urlToDownloadTool = `signingmanager/api-ui/v1/releases/noauth/${toolToBeUsed}/download`;
  console.log(
    "Tool to be downloaded and used {} and url is {}",
    toolToBeUsed,
    urlToDownloadTool
  );
  console.log("ui Api", uiAPIPrefix);
  const toolFileData = await getAPICall(urlToDownloadTool, {
    responseType: "arraybuffer",
  });
  //file writing part
  const clientToolsDownloadPath = path.join(tempDirectoryPath, toolToBeUsed);
  fs.writeFileSync(clientToolsDownloadPath, toolFileData);

  console.log("file after write ", fs.statSync(clientToolsDownloadPath).size);
  let extractPath = "";
  if (toolToBeUsed.includes(".zip")) {
    console.log(
      "tool is in a zip file trying to extract it",
      clientToolsDownloadPath
    );
    // await extract(clientToolsDownloadPath as string, {
    //   dir: tempDirectoryPath,
    // });
    await toolLib.extractZip(
      clientToolsDownloadPath as string,
      tempDirectoryPath
    );
    extractPath = path.join(
      tempDirectoryPath,
      toolToBeUsed.replace(".zip", "")
    );
    console.log("zip extraction complete , path is ", extractPath);
    }

//   const installationLocation = tl
//     .tool("")
//     .arg([
//       "product",
//       "where",
//       "Vendor='DigiCert Inc.' and name='DigiCert One Signing Manager Tools'",
//       "get",
//       "installlocation",
//       "/format:list",
//     ])
//     .execSync();

//   const { stdout } = installationLocation;
//   if (
//     stdout !== null &&
//     stdout.trim() !== "" &&
//     !stdout.includes("No Instance(s) Available")
//   ) {
//     extractPath = stdout.split("=")[1].trim();
//   } else {
//     throw new Error("Installation path is not found, internal error");
//   }
//   }
  return extractPath;
 }
export async function installMacTools(
  installationPath: string,
  toolToBeUsed: string
) {
  try {
    fs.mkdirSync(`${installationPath}`);
  } catch (err) {}
  const extractPath = await runMacToolBasedInstallationOrExtraction(
    toolToBeUsed,
    installationPath
  );

  console.log(
    "path where the ssm tools were installed/extracted is ",
    extractPath
  );

  let setExecutableFlagForSmctl: tr.ToolRunner = tl
    .tool("chmod")
    .arg("+x")
    .arg(path.join(extractPath, "smctl"));
  let syncRetCode: number = await setExecutableFlagForSmctl.exec();
  console.log("set executable flag for smctl" + syncRetCode);
  const pkcs11FileName = "smpkcs11.so";
  const configFilePath = await getConfigFilePath(pkcs11FileName, extractPath);

  return configFilePath;
}


